class Game {
	field int TLCX, TLCY, score;
	field boolean failed;
	field Array row1, row2, row3, row4;
	field Array col1, col2, col3, col4;

	/**
	  * Description: Creates a new 2048 game with a 4x4 grid. Dummy 
	  *              2048, or 2048 with a 6x6 grid, is not 
	  * 			 implemented here. The fields have the same name
	  *				 as the args without the Arg suffix, which is why
	  *				 it is there. 
	  * Argument definition:
	  *     TLCXArg: The top-left corner's x position of which this game
	  *           is displayed. Stands for Top-Left Corner X.
	  *     TLCYArg: The top-left corner's y position of which this game
	  *           is displayed. Stands for Top-Left Corner Y. 
	  */
	constructor Game new(int TLCXArg, int TLCYArg) {
		var int i;
		// set TLCX to TLCXArg. TLCX serves the same purpose as TLCXArg.
		let TLCX = TLCXArg;
		// set TLCY to TLCYArg. TLCY severs the same purpose as TLCYArg. 
		let TLCY = TLCYArg;
		// define the score, initialized at 0. Score is always divisible 
		// by 4 because score is increased by the result of merging 2 
		// numbers, not a very accurate measure of how well you're doing.
		let score = 0;
		// is the game failed?
		let failed = false;
		// use a for loop to set row1's, row2's, etc. and col1's, 
		// col2's, etc. elements to 0. in order to keep track of what 
		// number we're on, we use i, set to 0 by default. 
		let i = 0;

		let row1 = Array.new(4);
		let row2 = Array.new(4);
		let row3 = Array.new(4);
		let row4 = Array.new(4);
		let col1 = Array.new(4);
		let col2 = Array.new(4);
		let col3 = Array.new(4);
		let col4 = Array.new(4);

		while (i < 4) {
			let row1[i] = 0;
			let row2[i] = 0;
			let row3[i] = 0;
			let row4[i] = 0;
			let col1[i] = 0;
			let col2[i] = 0;
			let col3[i] = 0;
			let col4[i] = 0;
			let i = i + 1;
		}
		// tests below. they set row1/row2/row3/row4/col1/col2/col3/col4
		// to certain values and they test. 
		let row1[0] = 2;
		let row1[1] = 2;
		let row1[2] = 0;
		let row1[3] = 0;
		let row2[0] = 0;
		let row2[1] = 0;
		let row2[2] = 2;
		let row2[3] = 2;
		let row3[0] = 2;
		let row3[1] = 0;
		let row3[2] = 0;
		let row3[3] = 4;
		let row4[0] = 2;
		let row4[1] = 2;
		let row4[2] = 4;
		let row4[3] = 0;
		// let col1[0] = 16;
		// let col1[1] = 4;
		// let col1[2] = 4;
		// let col1[3] = 8;
		// let col2[0] = 32;
		// let col2[1] = 8;
		// let col2[2] = 8;
		// let col2[3] = 16;
		// let col3[0] = 64;
		// let col3[1] = 16;
		// let col3[2] = 16;
		// let col3[3] = 32;
		// let col4[0] = 128;
		// let col4[1] = 32;
		// let col4[2] = 32;
		// let col4[3] = 64;
		// spawn 2 random 2s/4s

		return this; // part of the language
	}

	/** 
	  * Description: Disposes of the 2048 board along with any other classes that 
	  *              need to be disposed of. 
	  */
	method void dispose() {
		do row1.dispose();
		do row2.dispose();
		do row3.dispose();
		do row4.dispose();
		do col1.dispose();
		do col2.dispose();
		do col3.dispose();
		do col4.dispose();
		do Memory.deAlloc(this);
		return;
	}

	/**
	  * Description: Displays the 2048 board along with the numbers. 
	  * Argument definition: None.
	  */
	method void display() {
		var int x, y, memAddress;

		// White background. Spans across the entire screen. 
		do Screen.setColor(false); // color: white
		do Screen.drawRectangle(0, 0, 511, 255); // color: white, coverage: all

		// Black rectangle. The rectangle has a padding of 4, meaning that
		// the top-left corner is actually 4 more to the top-left corner
		// of the screen than it would usually be. It has a size of 64, 
		// but it actually goes 4 extra to the bottom-right corner than it
		// would otherwise go to, which is what 68 is. 
		do Screen.setColor(true); // color: black
		// color: black, coverage: grid
		do Screen.drawRectangle(TLCX - 4, TLCY - 4, TLCX + 68, TLCY + 68);

		// White rectangles for each cell. Define x and y to 0. They 
		// represent what cell we're on. Use a while loop that's condition
		// is that y is less than 4.  
		let x = 0;
		let y = 0;
		while (y < 4) {
			/* Display a white square with a size of 14, starting from where
			 * the cell should start. The cell should start 16*x + 1 pixels 
			 * the right of TLCX and 16*y + 1 pixels down of TLCY. 
             */
            do Screen.setColor(false); // color: white
            // color: white, coverage: cell
            do Screen.drawRectangle(TLCX + (16*x) + 1, TLCY + (16*y) + 1, 
            	TLCX + (16*x) + 15, TLCX + (16*y) + 15);
            /*
			 *	Display the powers of 2 tiles: 
			 *	2/4/8/16/32/64/128/256/512/1024/2048
			 *	(/4096/8192/16384/32768/65536?). 
			 */

			/*
			 *	memAddress is where to start displaying the number. It is
			 *	always 17442 in this system, but you have to figure out by
			 *	yourself if you're copying this to another program. Generally,
			 *	the formula is 16384 + location, where location = TLCX/16 + 
			 *	TLCY*32. Then where does the extra 32 come from? If your screen
			 *	size is adjusted, this will be different. And, if you are coding
			 *	in a different language, you won't even need this formula. Maybe
			 *	it comes from an extra TLCY. The bitmap must contain a wall on 
			 *	the left and bottom because otherwise, the cell will have no 
			 *	borders. Each y is 16 pixels, and 16*32 = 512. That's where we 
			 *  get it from. 
			 */
			let memAddress = 17442 + (y*512) + x;
			// 2
			if (y = 0) {
				if (row1[x] = 2) {
					// 2 coding: represents a 16-bit image of a 2
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 2017);
					do Memory.poke(memAddress+96, 3121);
					do Memory.poke(memAddress+128, 2065);
					do Memory.poke(memAddress+160, 3073);
					do Memory.poke(memAddress+192, 1537);
					do Memory.poke(memAddress+224, 769);
					do Memory.poke(memAddress+256, 385);
					do Memory.poke(memAddress+288, 193);
					do Memory.poke(memAddress+320, 97);
					do Memory.poke(memAddress+352, 49);
					do Memory.poke(memAddress+384, 4081);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 1) {
				if (row2[x] = 2) {
					// 2 coding: represents a 16-bit image of a 2
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 2017);
					do Memory.poke(memAddress+96, 3121);
					do Memory.poke(memAddress+128, 2065);
					do Memory.poke(memAddress+160, 3073);
					do Memory.poke(memAddress+192, 1537);
					do Memory.poke(memAddress+224, 769);
					do Memory.poke(memAddress+256, 385);
					do Memory.poke(memAddress+288, 193);
					do Memory.poke(memAddress+320, 97);
					do Memory.poke(memAddress+352, 49);
					do Memory.poke(memAddress+384, 4081);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 2) {
				if (row3[x] = 2) {
					// 2 coding: represents a 16-bit image of a 2
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 2017);
					do Memory.poke(memAddress+96, 3121);
					do Memory.poke(memAddress+128, 2065);
					do Memory.poke(memAddress+160, 3073);
					do Memory.poke(memAddress+192, 1537);
					do Memory.poke(memAddress+224, 769);
					do Memory.poke(memAddress+256, 385);
					do Memory.poke(memAddress+288, 193);
					do Memory.poke(memAddress+320, 97);
					do Memory.poke(memAddress+352, 49);
					do Memory.poke(memAddress+384, 4081);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 3) {
				if (row4[x] = 2) {
					// 2 coding: represents a 16-bit image of a 2
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 2017);
					do Memory.poke(memAddress+96, 3121);
					do Memory.poke(memAddress+128, 2065);
					do Memory.poke(memAddress+160, 3073);
					do Memory.poke(memAddress+192, 1537);
					do Memory.poke(memAddress+224, 769);
					do Memory.poke(memAddress+256, 385);
					do Memory.poke(memAddress+288, 193);
					do Memory.poke(memAddress+320, 97);
					do Memory.poke(memAddress+352, 49);
					do Memory.poke(memAddress+384, 4081);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			}
			// 4
			if (y = 0) {
				if (row1[x] = 4) {
					// 4 coding: represents a 16-bit image of a 4
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1057);
					do Memory.poke(memAddress+96, 1057);
					do Memory.poke(memAddress+128, 1057);
					do Memory.poke(memAddress+160, 1057);
					do Memory.poke(memAddress+192, 1057);
					do Memory.poke(memAddress+224, 2017);
					do Memory.poke(memAddress+256, 1025);
					do Memory.poke(memAddress+288, 1025);
					do Memory.poke(memAddress+320, 1025);
					do Memory.poke(memAddress+352, 1025);
					do Memory.poke(memAddress+384, 1025);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 1) {
				if (row2[x] = 4) {
					// 4 coding: represents a 16-bit image of a 4
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1057);
					do Memory.poke(memAddress+96, 1057);
					do Memory.poke(memAddress+128, 1057);
					do Memory.poke(memAddress+160, 1057);
					do Memory.poke(memAddress+192, 1057);
					do Memory.poke(memAddress+224, 2017);
					do Memory.poke(memAddress+256, 1025);
					do Memory.poke(memAddress+288, 1025);
					do Memory.poke(memAddress+320, 1025);
					do Memory.poke(memAddress+352, 1025);
					do Memory.poke(memAddress+384, 1025);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 2) {
				if (row3[x] = 4) {
					// 4 coding: represents a 16-bit image of a 4
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1057);
					do Memory.poke(memAddress+96, 1057);
					do Memory.poke(memAddress+128, 1057);
					do Memory.poke(memAddress+160, 1057);
					do Memory.poke(memAddress+192, 1057);
					do Memory.poke(memAddress+224, 2017);
					do Memory.poke(memAddress+256, 1025);
					do Memory.poke(memAddress+288, 1025);
					do Memory.poke(memAddress+320, 1025);
					do Memory.poke(memAddress+352, 1025);
					do Memory.poke(memAddress+384, 1025);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 3) {
				if (row4[x] = 4) {
					// 4 coding: represents a 16-bit image of a 4
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1057);
					do Memory.poke(memAddress+96, 1057);
					do Memory.poke(memAddress+128, 1057);
					do Memory.poke(memAddress+160, 1057);
					do Memory.poke(memAddress+192, 1057);
					do Memory.poke(memAddress+224, 2017);
					do Memory.poke(memAddress+256, 1025);
					do Memory.poke(memAddress+288, 1025);
					do Memory.poke(memAddress+320, 1025);
					do Memory.poke(memAddress+352, 1025);
					do Memory.poke(memAddress+384, 1025);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			}

			// 8
			if (y = 0) {
				if (row1[x] = 8) {
					// 8 coding: represents a 16-bit image of a 8
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1985);
					do Memory.poke(memAddress+96, 3169);
					do Memory.poke(memAddress+128, 2081);
					do Memory.poke(memAddress+160, 2081);
					do Memory.poke(memAddress+192, 3169);
					do Memory.poke(memAddress+224, 1985);
					do Memory.poke(memAddress+256, 3169);
					do Memory.poke(memAddress+288, 2081);
					do Memory.poke(memAddress+320, 2081);
					do Memory.poke(memAddress+352, 3169);
					do Memory.poke(memAddress+384, 1985);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 1) {
				if (row2[x] = 8) {
					// 8 coding: represents a 16-bit image of a 8
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1985);
					do Memory.poke(memAddress+96, 3169);
					do Memory.poke(memAddress+128, 2081);
					do Memory.poke(memAddress+160, 2081);
					do Memory.poke(memAddress+192, 3169);
					do Memory.poke(memAddress+224, 1985);
					do Memory.poke(memAddress+256, 3169);
					do Memory.poke(memAddress+288, 2081);
					do Memory.poke(memAddress+320, 2081);
					do Memory.poke(memAddress+352, 3169);
					do Memory.poke(memAddress+384, 1985);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 2) {
				if (row3[x] = 8) {
					// 8 coding: represents a 16-bit image of a 8
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1985);
					do Memory.poke(memAddress+96, 3169);
					do Memory.poke(memAddress+128, 2081);
					do Memory.poke(memAddress+160, 2081);
					do Memory.poke(memAddress+192, 3169);
					do Memory.poke(memAddress+224, 1985);
					do Memory.poke(memAddress+256, 3169);
					do Memory.poke(memAddress+288, 2081);
					do Memory.poke(memAddress+320, 2081);
					do Memory.poke(memAddress+352, 3169);
					do Memory.poke(memAddress+384, 1985);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 3) {
				if (row4[x] = 8) {
					// 8 coding: represents a 16-bit image of a 8
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1985);
					do Memory.poke(memAddress+96, 3169);
					do Memory.poke(memAddress+128, 2081);
					do Memory.poke(memAddress+160, 2081);
					do Memory.poke(memAddress+192, 3169);
					do Memory.poke(memAddress+224, 1985);
					do Memory.poke(memAddress+256, 3169);
					do Memory.poke(memAddress+288, 2081);
					do Memory.poke(memAddress+320, 2081);
					do Memory.poke(memAddress+352, 3169);
					do Memory.poke(memAddress+384, 1985);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			}

			// 16
			if (y = 0) {
				if (row1[x] = 16) {
					// 16 coding: represents a 16-bit image of a 16
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 3857);
					do Memory.poke(memAddress+96, 6545);
					do Memory.poke(memAddress+128, 4241);
					do Memory.poke(memAddress+160, 145);
					do Memory.poke(memAddress+192, 145);
					do Memory.poke(memAddress+224, 3985);
					do Memory.poke(memAddress+256, 6545);
					do Memory.poke(memAddress+288, 4241);
					do Memory.poke(memAddress+320, 4241);
					do Memory.poke(memAddress+352, 6545);
					do Memory.poke(memAddress+384, 3857);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 1) {
				if (row2[x] = 16) {
					// 16 coding: represents a 16-bit image of a 16
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 3857);
					do Memory.poke(memAddress+96, 6545);
					do Memory.poke(memAddress+128, 4241);
					do Memory.poke(memAddress+160, 145);
					do Memory.poke(memAddress+192, 145);
					do Memory.poke(memAddress+224, 3985);
					do Memory.poke(memAddress+256, 6545);
					do Memory.poke(memAddress+288, 4241);
					do Memory.poke(memAddress+320, 4241);
					do Memory.poke(memAddress+352, 6545);
					do Memory.poke(memAddress+384, 3857);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 2) {
				if (row3[x] = 16) {
					// 16 coding: represents a 16-bit image of a 16
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 3857);
					do Memory.poke(memAddress+96, 6545);
					do Memory.poke(memAddress+128, 4241);
					do Memory.poke(memAddress+160, 145);
					do Memory.poke(memAddress+192, 145);
					do Memory.poke(memAddress+224, 3985);
					do Memory.poke(memAddress+256, 6545);
					do Memory.poke(memAddress+288, 4241);
					do Memory.poke(memAddress+320, 4241);
					do Memory.poke(memAddress+352, 6545);
					do Memory.poke(memAddress+384, 3857);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 3) {
				if (row4[x] = 16) {
					// 16 coding: represents a 16-bit image of a 16
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 3857);
					do Memory.poke(memAddress+96, 6545);
					do Memory.poke(memAddress+128, 4241);
					do Memory.poke(memAddress+160, 145);
					do Memory.poke(memAddress+192, 145);
					do Memory.poke(memAddress+224, 3985);
					do Memory.poke(memAddress+256, 6545);
					do Memory.poke(memAddress+288, 4241);
					do Memory.poke(memAddress+320, 4241);
					do Memory.poke(memAddress+352, 6545);
					do Memory.poke(memAddress+384, 3857);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			}

			// 32
			if (y = 0) {
				if (row1[x] = 32) {
					// 32 coding: represents a 16-bit image of a 32
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 15481);
					do Memory.poke(memAddress+96, 26317);
					do Memory.poke(memAddress+128, 17029);
					do Memory.poke(memAddress+160, 16513);
					do Memory.poke(memAddress+192, 24769);
					do Memory.poke(memAddress+224, 12409);
					do Memory.poke(memAddress+256, 6337);
					do Memory.poke(memAddress+288, 2177);
					do Memory.poke(memAddress+320, 3205);
					do Memory.poke(memAddress+352, 1741);
					do Memory.poke(memAddress+384, 32377);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 1) {
				if (row2[x] = 32) {
					// 32 coding: represents a 16-bit image of a 32 
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 15481);
					do Memory.poke(memAddress+96, 26317);
					do Memory.poke(memAddress+128, 17029);
					do Memory.poke(memAddress+160, 16513);
					do Memory.poke(memAddress+192, 24769);
					do Memory.poke(memAddress+224, 12409);
					do Memory.poke(memAddress+256, 6337);
					do Memory.poke(memAddress+288, 2177);
					do Memory.poke(memAddress+320, 3205);
					do Memory.poke(memAddress+352, 1741);
					do Memory.poke(memAddress+384, 32377);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 2) {
				if (row3[x] = 32) {
					// 32 coding: represents a 16-bit image of a 32
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 15481);
					do Memory.poke(memAddress+96, 26317);
					do Memory.poke(memAddress+128, 17029);
					do Memory.poke(memAddress+160, 16513);
					do Memory.poke(memAddress+192, 24769);
					do Memory.poke(memAddress+224, 12409);
					do Memory.poke(memAddress+256, 6337);
					do Memory.poke(memAddress+288, 2177);
					do Memory.poke(memAddress+320, 3205);
					do Memory.poke(memAddress+352, 1741);
					do Memory.poke(memAddress+384, 32377);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 3) {
				if (row4[x] = 32) {
					// 32 coding: represents a 16-bit image of a 32
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 15481);
					do Memory.poke(memAddress+96, 26317);
					do Memory.poke(memAddress+128, 17029);
					do Memory.poke(memAddress+160, 16513);
					do Memory.poke(memAddress+192, 24769);
					do Memory.poke(memAddress+224, 12409);
					do Memory.poke(memAddress+256, 6337);
					do Memory.poke(memAddress+288, 2177);
					do Memory.poke(memAddress+320, 3205);
					do Memory.poke(memAddress+352, 1741);
					do Memory.poke(memAddress+384, 32377);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			}

			// 64
			if (y = 0) {
				if (row1[x] = 64) {
					// 64 coding: represents a 16-bit image of a 64
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 17017);
					do Memory.poke(memAddress+96, 17101);
					do Memory.poke(memAddress+128, 17029);
					do Memory.poke(memAddress+160, 16901);
					do Memory.poke(memAddress+192, 16901);
					do Memory.poke(memAddress+224, 32381);
					do Memory.poke(memAddress+256, 16589);
					do Memory.poke(memAddress+288, 16517);
					do Memory.poke(memAddress+320, 16517);
					do Memory.poke(memAddress+352, 16589);
					do Memory.poke(memAddress+384, 16505);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 1) {
				if (row2[x] = 64) {
					// 64 coding: represents a 16-bit image of a 64 
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 17017);
					do Memory.poke(memAddress+96, 17101);
					do Memory.poke(memAddress+128, 17029);
					do Memory.poke(memAddress+160, 16901);
					do Memory.poke(memAddress+192, 16901);
					do Memory.poke(memAddress+224, 32381);
					do Memory.poke(memAddress+256, 16589);
					do Memory.poke(memAddress+288, 16517);
					do Memory.poke(memAddress+320, 16517);
					do Memory.poke(memAddress+352, 16589);
					do Memory.poke(memAddress+384, 16505);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 2) {
				if (row3[x] = 64) {
					// 64 coding: represents a 16-bit image of a 64
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 17017);
					do Memory.poke(memAddress+96, 17101);
					do Memory.poke(memAddress+128, 17029);
					do Memory.poke(memAddress+160, 16901);
					do Memory.poke(memAddress+192, 16901);
					do Memory.poke(memAddress+224, 32381);
					do Memory.poke(memAddress+256, 16589);
					do Memory.poke(memAddress+288, 16517);
					do Memory.poke(memAddress+320, 16517);
					do Memory.poke(memAddress+352, 16589);
					do Memory.poke(memAddress+384, 16505);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 3) {
				if (row4[x] = 64) {
					// 64 coding: represents a 16-bit image of a 64
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 17017);
					do Memory.poke(memAddress+96, 17101);
					do Memory.poke(memAddress+128, 17029);
					do Memory.poke(memAddress+160, 16901);
					do Memory.poke(memAddress+192, 16901);
					do Memory.poke(memAddress+224, 32381);
					do Memory.poke(memAddress+256, 16589);
					do Memory.poke(memAddress+288, 16517);
					do Memory.poke(memAddress+320, 16517);
					do Memory.poke(memAddress+352, 16589);
					do Memory.poke(memAddress+384, 16505);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			}

			// 128
			if (y = 0) {
				if (row1[x] = 128) {
					// 128 coding: represents a 16-bit image of a 128
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 14565);
					do Memory.poke(memAddress+96, 28085);
					do Memory.poke(memAddress+128, 17685);
					do Memory.poke(memAddress+160, 17669);
					do Memory.poke(memAddress+192, 28037);
					do Memory.poke(memAddress+224, 14469);
					do Memory.poke(memAddress+256, 27845);
					do Memory.poke(memAddress+288, 17509);
					do Memory.poke(memAddress+320, 17461);
					do Memory.poke(memAddress+352, 27669);
					do Memory.poke(memAddress+384, 14837);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 1) {
				if (row2[x] = 128) {
					// 128 coding: represents a 16-bit image of a 128
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 14565);
					do Memory.poke(memAddress+96, 28085);
					do Memory.poke(memAddress+128, 17685);
					do Memory.poke(memAddress+160, 17669);
					do Memory.poke(memAddress+192, 28037);
					do Memory.poke(memAddress+224, 14469);
					do Memory.poke(memAddress+256, 27845);
					do Memory.poke(memAddress+288, 17509);
					do Memory.poke(memAddress+320, 17461);
					do Memory.poke(memAddress+352, 27669);
					do Memory.poke(memAddress+384, 14837);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 2) {
				if (row3[x] = 128) {
					// 128 coding: represents a 16-bit image of a 128
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 14565);
					do Memory.poke(memAddress+96, 28085);
					do Memory.poke(memAddress+128, 17685);
					do Memory.poke(memAddress+160, 17669);
					do Memory.poke(memAddress+192, 28037);
					do Memory.poke(memAddress+224, 14469);
					do Memory.poke(memAddress+256, 27845);
					do Memory.poke(memAddress+288, 17509);
					do Memory.poke(memAddress+320, 17461);
					do Memory.poke(memAddress+352, 27669);
					do Memory.poke(memAddress+384, 14837);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 3) {
				if (row4[x] = 128) {
					// 128 coding: represents a 16-bit image of a 128
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 14565);
					do Memory.poke(memAddress+96, 28085);
					do Memory.poke(memAddress+128, 17685);
					do Memory.poke(memAddress+160, 17669);
					do Memory.poke(memAddress+192, 28037);
					do Memory.poke(memAddress+224, 14469);
					do Memory.poke(memAddress+256, 27845);
					do Memory.poke(memAddress+288, 17509);
					do Memory.poke(memAddress+320, 17461);
					do Memory.poke(memAddress+352, 27669);
					do Memory.poke(memAddress+384, 14837);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			}

			// 256
			if (y = 0) {
				if (row1[x] = 256) {
					// 256 coding: represents a 16-bit image of a 256
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 31677);
					do Memory.poke(memAddress+96, 18597);
					do Memory.poke(memAddress+128, 18597);
					do Memory.poke(memAddress+160, 2209);
					do Memory.poke(memAddress+192, 2225);
					do Memory.poke(memAddress+224, 2193);
					do Memory.poke(memAddress+256, 31641);
					do Memory.poke(memAddress+288, 18953);
					do Memory.poke(memAddress+320, 18957);
					do Memory.poke(memAddress+352, 18949);
					do Memory.poke(memAddress+384, 31677);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 1) {
				if (row2[x] = 256) {
					// 256 coding: represents a 16-bit image of a 256
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 31677);
					do Memory.poke(memAddress+96, 18597);
					do Memory.poke(memAddress+128, 18597);
					do Memory.poke(memAddress+160, 2209);
					do Memory.poke(memAddress+192, 2225);
					do Memory.poke(memAddress+224, 2193);
					do Memory.poke(memAddress+256, 31641);
					do Memory.poke(memAddress+288, 18953);
					do Memory.poke(memAddress+320, 18957);
					do Memory.poke(memAddress+352, 18949);
					do Memory.poke(memAddress+384, 31677);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 2) {
				if (row3[x] = 256) {
					// 256 coding: represents a 16-bit image of a 256
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 31677);
					do Memory.poke(memAddress+96, 18597);
					do Memory.poke(memAddress+128, 18597);
					do Memory.poke(memAddress+160, 2209);
					do Memory.poke(memAddress+192, 2225);
					do Memory.poke(memAddress+224, 2193);
					do Memory.poke(memAddress+256, 31641);
					do Memory.poke(memAddress+288, 18953);
					do Memory.poke(memAddress+320, 18957);
					do Memory.poke(memAddress+352, 18949);
					do Memory.poke(memAddress+384, 31677);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 3) {
				if (row4[x] = 256) {
					// 256 coding: represents a 16-bit image of a 256
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 31677);
					do Memory.poke(memAddress+96, 18597);
					do Memory.poke(memAddress+128, 18597);
					do Memory.poke(memAddress+160, 2209);
					do Memory.poke(memAddress+192, 2225);
					do Memory.poke(memAddress+224, 2193);
					do Memory.poke(memAddress+256, 31641);
					do Memory.poke(memAddress+288, 18953);
					do Memory.poke(memAddress+320, 18957);
					do Memory.poke(memAddress+352, 18949);
					do Memory.poke(memAddress+384, 31677);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			}

			// 512
			if (y = 0) {
				if (row1[x] = 512) {
					// 512 coding: represents a 16-bit image of a 512
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 14717);
					do Memory.poke(memAddress+96, 27909);
					do Memory.poke(memAddress+128, 17669);
					do Memory.poke(memAddress+160, 16645);
					do Memory.poke(memAddress+192, 24837);
					do Memory.poke(memAddress+224, 12605);
					do Memory.poke(memAddress+256, 4449);
					do Memory.poke(memAddress+288, 6465);
					do Memory.poke(memAddress+320, 3393);
					do Memory.poke(memAddress+352, 1377);
					do Memory.poke(memAddress+384, 32061);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 1) {
				if (row2[x] = 512) {
					// 512 coding: represents a 16-bit image of a 512
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 14717);
					do Memory.poke(memAddress+96, 27909);
					do Memory.poke(memAddress+128, 17669);
					do Memory.poke(memAddress+160, 16645);
					do Memory.poke(memAddress+192, 24837);
					do Memory.poke(memAddress+224, 12605);
					do Memory.poke(memAddress+256, 4449);
					do Memory.poke(memAddress+288, 6465);
					do Memory.poke(memAddress+320, 3393);
					do Memory.poke(memAddress+352, 1377);
					do Memory.poke(memAddress+384, 32061);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 2) {
				if (row3[x] = 512) {
					// 512 coding: represents a 16-bit image of a 512
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 14717);
					do Memory.poke(memAddress+96, 27909);
					do Memory.poke(memAddress+128, 17669);
					do Memory.poke(memAddress+160, 16645);
					do Memory.poke(memAddress+192, 24837);
					do Memory.poke(memAddress+224, 12605);
					do Memory.poke(memAddress+256, 4449);
					do Memory.poke(memAddress+288, 6465);
					do Memory.poke(memAddress+320, 3393);
					do Memory.poke(memAddress+352, 1377);
					do Memory.poke(memAddress+384, 32061);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 3) {
				if (row4[x] = 512) {
					// 512 coding: represents a 16-bit image of a 512
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 14717);
					do Memory.poke(memAddress+96, 27909);
					do Memory.poke(memAddress+128, 17669);
					do Memory.poke(memAddress+160, 16645);
					do Memory.poke(memAddress+192, 24837);
					do Memory.poke(memAddress+224, 12605);
					do Memory.poke(memAddress+256, 4449);
					do Memory.poke(memAddress+288, 6465);
					do Memory.poke(memAddress+320, 3393);
					do Memory.poke(memAddress+352, 1377);
					do Memory.poke(memAddress+384, 32061);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			}

			// 1024
			if (y = 0) {
				if (row1[x] = 1024) {
					// 1024 coding: represents a 16-bit image of a 1024
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1);
					do Memory.poke(memAddress+96, 1);
					do Memory.poke(memAddress+128, 21029);
					do Memory.poke(memAddress+160, 22389);
					do Memory.poke(memAddress+192, 21845);
					do Memory.poke(memAddress+224, 29781);
					do Memory.poke(memAddress+256, 18005);
					do Memory.poke(memAddress+288, 17269);
					do Memory.poke(memAddress+320, 18213);
					do Memory.poke(memAddress+352, 1);
					do Memory.poke(memAddress+384, 1);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 1) {
				if (row2[x] = 1024) {
					// 1024 coding: represents a 16-bit image of a 1024
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1);
					do Memory.poke(memAddress+96, 1);
					do Memory.poke(memAddress+128, 21029);
					do Memory.poke(memAddress+160, 22389);
					do Memory.poke(memAddress+192, 21845);
					do Memory.poke(memAddress+224, 29781);
					do Memory.poke(memAddress+256, 18005);
					do Memory.poke(memAddress+288, 17269);
					do Memory.poke(memAddress+320, 18213);
					do Memory.poke(memAddress+352, 1);
					do Memory.poke(memAddress+384, 1);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 2) {
				if (row3[x] = 1024) {
					// 1024 coding: represents a 16-bit image of a 1024
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1);
					do Memory.poke(memAddress+96, 1);
					do Memory.poke(memAddress+128, 21029);
					do Memory.poke(memAddress+160, 22389);
					do Memory.poke(memAddress+192, 21845);
					do Memory.poke(memAddress+224, 29781);
					do Memory.poke(memAddress+256, 18005);
					do Memory.poke(memAddress+288, 17269);
					do Memory.poke(memAddress+320, 18213);
					do Memory.poke(memAddress+352, 1);
					do Memory.poke(memAddress+384, 1);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 3) {
				if (row4[x] = 1024) {
					// 1024 coding: represents a 16-bit image of a 1024
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1);
					do Memory.poke(memAddress+96, 1);
					do Memory.poke(memAddress+128, 21029);
					do Memory.poke(memAddress+160, 22389);
					do Memory.poke(memAddress+192, 21845);
					do Memory.poke(memAddress+224, 29781);
					do Memory.poke(memAddress+256, 18005);
					do Memory.poke(memAddress+288, 17269);
					do Memory.poke(memAddress+320, 18213);
					do Memory.poke(memAddress+352, 1);
					do Memory.poke(memAddress+384, 1);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			}
			// 2048
			if (y = 0) {
				if (row1[x] = 2048) {
					// 2048 coding: represents a 16-bit image of a 2048
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1);
					do Memory.poke(memAddress+96, 1);
					do Memory.poke(memAddress+128, 1);
					do Memory.poke(memAddress+160, 30445);
					do Memory.poke(memAddress+192, 22185);
					do Memory.poke(memAddress+224, 30381);
					do Memory.poke(memAddress+256, 21669);
					do Memory.poke(memAddress+288, 29933);
					do Memory.poke(memAddress+320, 1);
					do Memory.poke(memAddress+352, 1);
					do Memory.poke(memAddress+384, 1);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 1) {
				if (row2[x] = 2048) {
					// 2048 coding: represents a 16-bit image of a 2048
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1);
					do Memory.poke(memAddress+96, 1);
					do Memory.poke(memAddress+128, 1);
					do Memory.poke(memAddress+160, 30445);
					do Memory.poke(memAddress+192, 22185);
					do Memory.poke(memAddress+224, 30381);
					do Memory.poke(memAddress+256, 21669);
					do Memory.poke(memAddress+288, 29933);
					do Memory.poke(memAddress+320, 1);
					do Memory.poke(memAddress+352, 1);
					do Memory.poke(memAddress+384, 1);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 2) {
				if (row3[x] = 2048) {
					// 2048 coding: represents a 16-bit image of a 2048
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1);
					do Memory.poke(memAddress+96, 1);
					do Memory.poke(memAddress+128, 1);
					do Memory.poke(memAddress+160, 30445);
					do Memory.poke(memAddress+192, 22185);
					do Memory.poke(memAddress+224, 30381);
					do Memory.poke(memAddress+256, 21669);
					do Memory.poke(memAddress+288, 29933);
					do Memory.poke(memAddress+320, 1);
					do Memory.poke(memAddress+352, 1);
					do Memory.poke(memAddress+384, 1);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			} if (y = 3) {
				if (row4[x] = 2048) {
					// 2048 coding: represents a 16-bit image of a 2048
					do Memory.poke(memAddress+0, 1);
					do Memory.poke(memAddress+32, 1);
					do Memory.poke(memAddress+64, 1);
					do Memory.poke(memAddress+96, 1);
					do Memory.poke(memAddress+128, 1);
					do Memory.poke(memAddress+160, 30445);
					do Memory.poke(memAddress+192, 22185);
					do Memory.poke(memAddress+224, 30381);
					do Memory.poke(memAddress+256, 21669);
					do Memory.poke(memAddress+288, 29933);
					do Memory.poke(memAddress+320, 1);
					do Memory.poke(memAddress+352, 1);
					do Memory.poke(memAddress+384, 1);
					do Memory.poke(memAddress+416, 1);
					do Memory.poke(memAddress+448, 1);
					do Memory.poke(memAddress+480, -1);
				}
			}

			// Future plans: 4096, 8192, 16384, 32768, 65536, and 131072

			// Don't forget to increment x! If x is greater than 3, increment y and 
			// reset x. 
			let x = x + 1;
			if (x > 3) {
				let y = y + 1;
				let x = 0;
			}
		}
		
		return; // part of the language
	}

	/**
	  * Description: You might agree that this is getting insane, but this function
	  *              is so that you can retry the game. 
	  */
	method void setFailed() {
		let failed = true;
		return;
	}

	/**
	  * Description: If the game is failed, this function returns true. Otherwise, 
	  *              it returns false. 
	  */
	method boolean getFail() {
		return failed;
	}

	/**
	  * Description: Does what it is named for; converts the row representation
	  *              with the column representation. Prints column 1 first, 
	  *              column 2 second, etc. if testing. After each number, prints 
	  *              a line. Displays the column itself from top-to-bottom in 
	  *              the actual column to top-to-bottom on the print screen. 
	  * Argument definition: None.
	  */
	method void convertRowsToCols() {
		// top-left corner: column 1, row 1. 
		let col1[0] = row1[0];
		// top row, middle-left column, or row 1, column 2. 
		let col2[0] = row1[1];
		// top row, middle-right column, or row 1, column 3. 
		let col3[0] = row1[2];
		// top-right corner: row 1, column 4. 
		let col4[0] = row1[3];
		// repeat for row 2. 
		let col1[1] = row2[0];
		let col2[1] = row2[1];
		let col3[1] = row2[2];
		let col4[1] = row2[3];
		// repeat for row 3. 
		let col1[2] = row3[0];
		let col2[2] = row3[1];
		let col3[2] = row3[2];
		let col4[2] = row3[3];
		// repeat for row 4. 
		let col1[3] = row4[0];
		let col2[3] = row4[1];
		let col3[3] = row4[2];
		let col4[3] = row4[3];
		return; // part of the language
	}

	/**
	  * Description: Does what it is named for; converts the col representation
	  *              with the row representation. 
	  * Argument definition: None.
	  */
	method void convertColsToRows() {
		// each pair in convertRowsToCols is setting the row representation to the 
		// the column representation. swapping sides sets the column representation
		// t the row representation. 
		let row1[0] = col1[0];
		let row1[1] = col2[0];
		let row1[2] = col3[0];
		let row1[3] = col4[0];
		let row2[0] = col1[1];
		let row2[1] = col2[1];
		let row2[2] = col3[1];
		let row2[3] = col4[1];
		let row3[0] = col1[2];
		let row3[1] = col2[2];
		let row3[2] = col3[2];
		let row3[3] = col4[2];
		let row4[0] = col1[3];
		let row4[1] = col2[3];
		let row4[2] = col3[3];
		let row4[3] = col4[3];

		return; // part of the language
	}

	/**
	  * Description: Moves all numbers to the left as much as they can. If two of
	  *              the numbers collide with eachother, they stop at each other. 
	  */
	method void slideLeft() {
		var int i, j, temp;
		var boolean exit;
		// i should be 1. it represents the index of the access for row. (doesn't
		// include 0 because there's nothing to slide into)
		let i = 1;
		// only iterate if i is in the indices of row. 
		while (i < 4) {
			let exit = false;
			// check if the number is non-zero.
			if (~(row1[i] = 0)) {
				// if it is, then you can move it until it's all the way to the
				// left or about to hit another number.
				let j = i;
				while (~exit) {
					let j = j - 1;
					// case 1: it hits another number. 
					if (~(row1[j] = 0)) {
						let exit = true;
						let j = j + 1;
						let temp = row1[i];
						let row1[i] = 0;
						let row1[j] = temp;
					}
					// case 2: it hits all the way to the left.
					if ((j = 0) & ~exit) {
						let exit = true;
						let temp = row1[i];
						let row1[i] = 0;
						let row1[j] = temp;
					}
				}
			}
			let i = i + 1;
		}
		// repeat for the other rows. 
		let i = 1;
		let exit = false;
		// only iterate if i is in the indices of row. 
		while (i < 4) {
			let exit = false;
			// check if the number is non-zero.
			if (~(row2[i] = 0)) {
				// if it is, then you can move it until it's all the way to the
				// left or about to hit another number.
				let j = i;
				while (~exit) {
					let j = j - 1;
					// case 1: it hits another number. 
					if (~(row2[j] = 0)) {
						let exit = true;
						let j = j + 1;
						let temp = row2[i];
						let row2[i] = 0;
						let row2[j] = temp;
					}
					// case 2: it hits all the way to the left.
					if ((j = 0) & ~exit) {
						let exit = true;
						let temp = row2[i];
						let row2[i] = 0;
						let row2[j] = temp;
					}
				}
			}
			let i = i + 1;
		}

		let i = 1;
		let exit = false;
		// only iterate if i is in the indices of row. 
		while (i < 4) {
			let exit = false;
			// check if the number is non-zero.
			if (~(row3[i] = 0)) {
				// if it is, then you can move it until it's all the way to the
				// left or about to hit another number.
				let j = i;
				while (~exit) {
					let j = j - 1;
					// case 1: it hits another number. 
					if (~(row3[j] = 0)) {
						let exit = true;
						let j = j + 1;
						let temp = row3[i];
						let row3[i] = 0;
						let row3[j] = temp;
					}
					// case 2: it hits all the way to the left.
					if ((j = 0) & ~exit) {
						let exit = true;
						let temp = row3[i];
						let row3[i] = 0;
						let row3[j] = temp;
					}
				}
			}
			let i = i + 1;
		}
		let i = 1;
		let exit = false;
		// only iterate if i is in the indices of row. 
		while (i < 4) {
			let exit = false;
			// check if the number is non-zero.
			if (~(row4[i] = 0)) {
				// if it is, then you can move it until it's all the way to the
				// left or about to hit another number.
				let j = i;
				while (~exit) {
					let j = j - 1;
					// case 1: it hits another number. 
					if (~(row4[j] = 0)) {
						let exit = true;
						let j = j + 1;
						let temp = row4[i];
						let row4[i] = 0;
						let row4[j] = temp;
					}
					// case 2: it hits all the way to the left.
					if ((j = 0) & ~exit) {
						let exit = true;
						let temp = row4[i];
						let row4[i] = 0;
						let row4[j] = temp;
					}
				}
			}
			let i = i + 1;
		}
		return; // part of the language
	}

	/** 
	  * Description: Merges any pair of horizontally adjacent numbers. 
	  */
	method void mergeHorizontal() {
		var int i;
		
		let i = 0; // this represents the pair of row1[0] and row1[1]
		while (i < 3) { // i = 3 represents row[3] and row[4], not existent
			// each row!
			// row 1
			if (row1[i] = row1[i+1]) {
				let row1[i] = row1[i]*2;
				let row1[i + 1] = 0;
			}
			// row 2
			if (row2[i] = row2[i+1]) {
				let row2[i] = row2[i]*2;
				let row2[i + 1] = 0;
			}
			// row 3
			if (row3[i] = row3[i+1]) {
				let row3[i] = row3[i]*2;
				let row3[i + 1] = 0;
			}
			// row 4
			if (row4[i] = row4[i+1]) {
				let row4[i] = row4[i]*2;
				let row4[i + 1] = 0;
			}
			let i = i + 1;
		}
		return; // part of the language
	}

	/**
	  * Description: Replicates the left command on the real 2048 app. 
	  */
	method void moveLeft() {
		do slideLeft();
		do mergeHorizontal();
		do slideLeft();
		return; // part of the language
	}

	/** 
	  * Description: Spawns a random 2 or 4 according to the Main.random() function
	  */
	method void spawnRandomNum() {
		var int location, row, col, iterations, num;
		// the number of iterations is important. if we do this for 160 times in a
		// row, the game is lost. 
		let iterations = 0;
		// is the number that is spawned a 2 or a 4?
		let num = 2;
		if (Main.random() > 12) {
			let num = 4;
		}
		while (iterations < 160) {
			// important: iterations!
			let iterations = iterations + 1;
			// always generates a value between 0 and 16, what we want it to be.
			let location = Main.random();
			// column must be less than 4 but otherwise is always equal to location
			let col = Main.modulus(location, 4);
			// row is always location/4. you can go check yourself. 
			let row = location/4;
			// now assign it! return if there's something available. 
			if (row = 0) {
				if (row1[col] = 0) {
					let row1[col] = num;
					return;
				}
			} if (row = 1) {
				if (row2[col] = 0) {
					let row2[col] = num;
					return;
				}
			} if (row = 2) {
				if (row3[col] = 0) {
					let row3[col] = num;
					return;
				}
			} if (row = 3) {
				if (row4[col] = 0) {
					let row4[col] = num;
					return;
				}
			} 
		}
		let failed = true;
		return;
	}
}